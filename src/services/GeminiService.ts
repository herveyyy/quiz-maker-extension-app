import { GoogleGenAI } from '@google/genai';

type GeminiConfig = {
  apiKey: string;
  model?: string;
};

type QuizGenerationRequest = {
  documentContent: string;
  title: string;
  description: string;
  type: 'quiz' | 'assignment';
  points: number;
  timeLimit: number;
  difficulty: 'easy' | 'medium' | 'hard';
  questionCount: number;
};

type Question = {
  id: string;
  question: string;
  type: 'multiple_choice' | 'true_false' | 'short_answer' | 'essay';
  options?: string[];
  correctAnswer?: string;
  points: number;
};

type GeneratedQuiz = {
  title: string;
  description: string;
  questions: Question[];
  totalPoints: number;
};

export class GeminiService {
  private genAI: GoogleGenAI;
  private model: string;

  constructor(config: GeminiConfig) {
    this.genAI = new GoogleGenAI({ apiKey: config.apiKey});
    this.model = config.model || 'gemini-2.5-flash';
  }

  async generateQuiz(request: QuizGenerationRequest): Promise<GeneratedQuiz> {
    console.log('ðŸ¤– GeminiService: Generating quiz...');
    
    const prompt = this.buildPrompt(request);
    
    try {
      const result = await this.genAI.models.generateContent({
        model: this.model,
        contents: prompt,
      });

      const generatedText = result.text;
      
      if (!generatedText) {
        throw new Error('No content generated by Gemini API');
      }

      console.log('ðŸ“Š Raw Gemini Response:', generatedText);
      
      return this.parseGeneratedQuiz(generatedText, request);
    } catch (error) {
      console.error('Error generating quiz with Gemini:', error);
      throw new Error(`Failed to generate quiz: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }


  private buildPrompt(request: QuizGenerationRequest): string {
    const { documentContent, title, description, type, points, timeLimit, difficulty, questionCount } = request;
    return `
Create a ${type} based on this document content:

${documentContent}

Requirements:
- Title: ${title}
- Description: ${description}
- Points: ${points}
- Time Limit: ${timeLimit} minutes
- Difficulty: ${difficulty}
- Number of Questions: ${questionCount}

Return the quiz in the following JSON format:
{
  "title": "${title}",
  "description": "${description}",
  "questions": [
  {
  "id": "unique_id",
  "question": "Question text here",
 "type": "multiple_choice | true_false | short_answer | essay | multiple_select",
 "options": ["Option A", "Option B", "Option C", "Option D"],
 "correctAnswer": ["Correct answer 1", "Correct answer 2"],
  "points": 10
  } // Repeat for remaining questions
 ],
  "totalPoints": ${points}
}

Ensure the JSON is valid and properly formatted. Include exactly ${questionCount} questions in the "questions" array and set "totalPoints" correctly.
    `.trim();
  }
  private parseGeneratedQuiz(generatedText: string, request: QuizGenerationRequest): GeneratedQuiz {
    try {
      console.log('ðŸ¤– GeminiService: Parsing generated quiz...');
      console.log('ðŸ“‹ Raw Generated Text:', generatedText);
      
      // Extract JSON from the generated text
      const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No valid JSON found in generated text');
      }

      console.log('ðŸ” Extracted JSON:', jsonMatch[0]);
      const quizData = JSON.parse(jsonMatch[0]);
      console.log('ðŸ“Š Parsed Quiz Data:', quizData);
      
      // Validate the structure
      if (!quizData.questions || !Array.isArray(quizData.questions)) {
        throw new Error('Invalid quiz structure: missing questions array');
      }

      // Ensure all questions have required fields
      const validatedQuestions = quizData.questions.map((q: any, index: number) => ({
        id: q.id || `q_${index + 1}`,
        question: q.question || `Question ${index + 1}`,
        type: q.type || 'multiple_choice',
        options: q.options || [],
        correctAnswer: q.correctAnswer || '',
        points: q.points || Math.floor(request.points / request.questionCount),
      }));

      console.log('ðŸ¤– GeminiService: Quiz parsing complete', {
        questionCount: validatedQuestions.length,
        totalPoints: quizData.totalPoints || request.points
      });

      // Log raw data structure as requested
      console.log('ðŸ“‹ Raw Questions Array:', JSON.stringify(validatedQuestions, null, 2));
      console.log('ðŸ“‹ Raw Quiz Object:', JSON.stringify({
        title: quizData.title || request.title,
        description: quizData.description || request.description,
        questions: validatedQuestions,
        totalPoints: quizData.totalPoints || request.points,
      }, null, 2));

      return {
        title: quizData.title || request.title,
        description: quizData.description || request.description,
        questions: validatedQuestions,
        totalPoints: quizData.totalPoints || request.points,
      };
    } catch (error) {
      console.error('Error parsing generated quiz:', error);
      throw new Error(`Failed to parse generated quiz: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async extractTextFromFile(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (event) => {
        const content = event.target?.result as string;
        if (!content) {
          reject(new Error('Failed to read file content'));
          return;
        }

        // For now, we'll just return the raw content
        // In a real implementation, you'd want to use a library like pdf-parse for PDFs
        // or mammoth for Word documents
        resolve(content);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to read file'));
      };
      
      reader.readAsText(file);
    });
  }
}